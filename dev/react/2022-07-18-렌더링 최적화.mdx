---
slug: 렌더링성능최적화
title: 렌더링 성능을 최적화하는 방법
authors: [yjh]
tags: [리액트, Hook, useCallback]
draft: true
---

<div className="preview">
  React.memo와 useMemo, userCallback을 사용해서 컴포넌트 렌더링 성능을 <br />
  최적화 하는 방법에 대해 알아보자.
</div>

<!--truncate-->

우선 컴포넌트가 리렌더링되는 조건은 아래와 같다.

<br />

1. 자신의 state가 변경 될 때
2. props가 변경될 때
3. 부모 컴포넌트가 리렌더링 될 때

## React.memo를 사용한 최적화

우선 극단적인 예시로 검색어 입력 하고 검색 버튼을 클릭 시 매번 10,000개의 아이템 리스트를 보여주는 컴포넌트가 있다.

```jsx
function App() {
  const [keyword, setKeyword] = useState('');
  const [data, setData] = useState([]);

  const onClickSearch = () => {
    setData(Array(10000).fill(keyword));
  };

  return (
    <div className="App">
      <input onChange={e => setKeyword(e.target.value)} />
      <button onClick={onClickSearch}>검색</button>

      <List data={data} />
    </div>
  );
}

const List = ({ data = [] }) => {
  console.log('list render');

  return (
    <div>
      {data.map((v, i) => (
        <div key={i}>아이템</div>
      ))}
    </div>
  );
};
```

input입력 시 매번 keyword에 값을 저장하고 이에따라 App컴포넌트가 리렌더링 된다.

<br />

`List 컴포넌트는 검색 버튼 클릭했을 때만 데이터가 변경되고 리런더링이 되어야 하지만`  
`keyword 값이 바뀔 때마다 매번 불필요한 리렌더링이 발생하고 있다.`

<br />

이때 List 컴포넌트를 React.memo로 감싸주면 불필요한 렌더링이 일어나지 않는다.

```jsx
const List = React.memo(({ data = [] }) => {
  console.log('list render');

  return (
    <div>
      {data.map((v, i) => (
        <div key={i}>아이템</div>
      ))}
    </div>
  );
});
```

<br />

물론 아래처럼 불필요한 렌더링을 일으키는 요소들을(여기에선 input이 해당) 컴포넌트로 분리해서 사용하면 해결되는 문제이긴하다.

```jsx
const SearchBox = ({ onClickSearch }) => {
  const [keyword, setKeyword] = useState('');

  return (
    <div>
      <input onChange={e => setKeyword(e.target.value)} />
      <button onClick={onClickSearch}>검색</button>
    </div>
  );
};
```

> 꼭 필요한 상황에서만 사용하는게 좋다.
